### 1. Общее описание проекта

**1.1. Название проекта:** Jiro

**1.2. Концепция:** "Jiro" — это веб-приложение для управления проектами по методологии Kanban с элементами Scrum. Система предназначена для команд, которым нужен гибкий инструмент для ведения задач, отслеживания прогресса и аналитики. Ключевой особенностью является возможность создавать иерархические структуры задач, где каждая сложная задача может иметь собственную Kanban-доску с подзадачами, формируя дерево зависимостей.
### 2. Логика аутентификации и авторизации

#### 2.1. Процесс входа (Login)

1. **Запрос:** Пользователь отправляет `POST /api/auth/login` с телом `{ "email": "...", "password": "..." }`.
2. **Валидация:** Контроллер `AuthController` принимает данные.
3. **Бизнес-логика (AuthService):**
    - Находит пользователя в таблице `USER` по `email`.
    - Сравнивает хэш пароля из БД с хэшем от введенного пароля (используя `bcrypt`).
    - Если пароли совпадают, генерируется пара токенов:
        - **Access Token:** Короткоживущий (15-30 минут), содержит `user_id`, `email`, `roles`. Он **stateless**.
        - **Refresh Token:** Длинная случайная строка, долгоживущий (недели).
    - **Хеширование Refresh Token:** Вычисляется криптографический хэш от refresh-токена.
    - **Сохранение сессии:** Создается запись в таблице `REFRESH_TOKEN` с `user_id`, `token_hash`, `expires_at`, `user_agent`, `ip_address`.
4. **Ответ:** Сервер возвращает клиенту JSON: `{ "accessToken": "...", "refreshToken": "..." }`.
#### 2.2. Процесс обновления токена (Refresh)

1. **Запрос:** Когда Access Token истек, фронтенд отправляет `POST /api/auth/refresh` с телом `{ "refreshToken": "..." }`.
2. **Бизнес-логика (AuthService):**
    - Находит в `REFRESH_TOKEN` запись, хеш которой совпадает с хешем от полученного токена.
    - Проверяет, что `is_revoked = false` и `expires_at` не наступил.
    - Если все в порядке, генерируется **новая пара** Access и Refresh токенов.
    - Обновляет запись в `REFRESH_TOKEN`: записывает новый `token_hash` и обновляет `last_used_at`. Это называется "ротация токенов" и повышает безопасность.
3. **Ответ:** Сервер возвращает новую пару токенов
#### 2.3. Проверка прав на каждом запросе (Authorization Middleware)

Каждый запрос к эндпоинту вида `/api/projects/...` проходит через middleware (промежуточное ПО) авторизации.

1. **Извлечение токена:** Middleware берет токен из заголовка `Authorization: Bearer <token>`.
2. **Верификация JWT:** Проверяется подпись и срок действия токена. Если невалиден — сразу ошибка `401 Unauthorized`.
3. **Получение данных:** Из полезной нагрузки (payload) JWT извлекается `user_id`.
4. **Проверка прав (самое важное):**
    - Из URL и тела запроса определяется, к какому `project_id` и к какому `resource` (задача, комментарий) пытается получить доступ пользователь.
    - Система делает запрос к БД, чтобы найти роль пользователя в этом проекте (`PROJECT_MEMBER` -> `PROJECT_ROLE`).
    - Затем проверяется, есть ли у этой роли нужное разрешение (`PROJECT_PERMISSION` -> `PERMISSION`) для данного `action` и `resource`.
    - Например, для `PUT /api/issues/123` система проверит, имеет ли пользователь право `edit` на `resource: issue` в `scope: project` или `scope: own`.
5. **Результат:** Если права есть — запрос передается дальше в контроллер. Если нет — ошибка `403 Forbidden`.

### 3. Логика управления сущностями

#### 3.1. Управление задачами (Issues) и досками

Это ядро системы, реализующее паттерн "задача как проект".

- **Создание простой задачи:** `POST /api/projects/:projectId/issues`.
    
    - Логика: `IssueService` создает запись в `ISSUE` с `project_id` из URL и `parent_issue_id = NULL`. `board_id` тоже `NULL`.
- **Превращение задачи в "сложную" (создание подзадач):** `POST /api/issues/:issueId/convert-to-complex`.
    
    - **Проверка прав:** Сначала проверяется, имеет ли пользователь право на управление сложными задачами.
    - **Логика:**
        1. `BoardService` создает новую запись в `BOARD` с `name` по умолчанию и привязкой к `issue_id`.
        2. `BoardService` создает для этой доски стандартные колонки ("To Do", "In Progress", "Done") в таблице `COLUMN`.
        3. `IssueService` обновляет запись задачи, устанавливая `board_id` на ID только что созданной доски.
- **Создание подзадачи:** `POST /api/boards/:boardId/issues`.
    
    - **Логика:** Контроллер сначала определяет, какой задаче принадлежит эта доска (`board.issue_id`). Затем `IssueService` создает новую запись в `ISSUE`, где `parent_issue_id` устанавливается равным ID этой родительской задачи.
- **Перетаскивание задачи на доске (Drag & Drop):** `PUT /api/issues/:issueId/column`.
    
    - **Запрос:** `{ "columnId": 5 }`.
    - **Логика:** `IssueService` обновляет запись задачи, меняя ее статус на тот, который соответствует новой колонке. Это позволяет связать статус и положение на доске.
- **Построение дерева задач:** `GET /api/projects/:projectId/tree`.
    
    - **Логика:**
        1. `IssueService` делает один запрос, чтобы получить **все** задачи проекта (`SELECT * FROM ISSUE WHERE project_id = ?`).
        2. на фронтенде из этого плоского списка строится древовидная структура на основе `parent_issue_id`. Это намного эффективнее, чем делать множество рекурсивных запросов к БД.
    
#### 3.2. Система уведомлений 

Уведомления не создаются "просто так". Они являются реакцией на события.

- **Триггеры:** В ключевых местах кода (создание задачи, добавление комментария, назначение исполнителя) вызывается метод `NotificationService.notify(eventType, context)`.
- **Логика `NotificationService.notify()`:**
    1. **Определение получателей:** На основе `eventType` и `context` (например, ID задачи) определяется, кто должен получить уведомление.
        - `task_assigned`: все новые исполнители задачи.
        - `comment_added`: автор задачи, другие исполнители, упомянутые пользователи (`@username`).
    2. **Фильтрация по настройкам:** Для каждого потенциального получателя делается запрос в `USER_NOTIFICATION_PREFERENCES`, чтобы проверить, включены ли у него уведомления этого типа (`is_enabled_in_app`).
    3. **Создание уведомления:** Для каждого прошедшего фильтра пользователя создается запись в `NOTIFICATION`.
    4. **Асинхронная отправка (Email):** Если в настройках включен email, `NotificationService` не отправляет письмо сразу, а добавляет задачу в очередь (например, `send_email_job` с ID уведомления). Отдельный worker (фоновый процесс) возьмет эту задачу и отправит email.
### 4. Логика фоновых процессов и аналитики

Эти процессы работают независимо от пользовательских запросов и обеспечивают производительность и функциональность системы.

#### 4.1. Расчет метрик для дашборда 

- **Запуск:** Скрипт запускается по расписанию (например, каждый час).
- **Логика скрипта (`DashboardSnapshotter`):**
    1. Получает список всех активных проектов.
    2. Для каждого проекта выполняет "тяжелые" аналитические запросы:
        - `COUNT(*) FROM ISSUE WHERE project_id = ? AND status = 'Done'`
        - `AVG(TIMESTAMPDIFF(HOUR, created_at, updated_at)) FROM ISSUE WHERE project_id = ? AND status = 'Done'`
        - И так далее для всех метрик.
    3. Очищает старые снапшоты за этот день.
    4. Вставляет новые результаты в таблицу `PROJECT_DASHBOARD_SNAPSHOT` с текущей датой.
- **Результат:** Когда пользователь открывает дашборд, сервер делает один быстрый запрос в `PROJECT_DASHBOARD_SNAPSHOT`, не нагружая основные таблицы.
  
#### 4.2. Логика управления Спринтами (Scrum)

Спринт — это временной контейнер для задач, который проходит через четко определенные временные отрезки. Вся логика инкапсулирована в `SprintService` и тесно связана с `IssueService`.

- **Эндпоинт:** `POST /api/projects/:projectId/sprints`
    
- **Запрос:** `{ "name": "Sprint 15", "goal": "Реализовать авторизацию", "startDate": "2023-11-01T09:00:00Z", "endDate": "2023-11-14T18:00:00Z" }`
    
- **Логика (`SprintService.createSprint`):**
    
    1. **Проверка прав:** Убедиться, что у пользователя есть разрешение на управление спринтами (`sprint_manage`) в этом проекте.
    2. **Валидация:** Проверить, что `startDate` раньше `endDate`. Убедиться, что новый спринт не пересекается по времени с другим `ACTIVE` спринтом в том же проекте (бизнес-правило, которое предотвращает хаос).
    3. **Создание:** Создать запись в таблице `SPRINT`.
       
**Добавление задач в спринт:**

- **Эндпоинт:** `PUT /api/sprints/:sprintId/issues`
- **Запрос:** `{ "issueIds": [123, 124, 125] }`
- **Логика (`SprintService.addIssuesToSprint`):**
    1. **Проверка прав:** Убедиться, что пользователь может планировать спринты.
    2. **Ключевая валидация:** Задача не может одновременно находиться в двух активных/планируемых спринтах. Сначала нужно "убрать" задачи из других незавершенных спринтов. Сервер выполняет это автоматически.
    3. **Назначение:** Добавить новые связи в связующую таблицу.
**Завершение спринта:**

- **Эндпоинт:** `POST /api/sprints/:sprintId/complete`
- **Запрос:** `{ "moveIncompleteIssuesTo": { "type": "backlog" } }` или `{ "type": "sprint", "targetSprintId": 16 }`
- **Логика (`SprintService.completeSprint`):**
    1. **Проверка прав**
    2. **Валидация:** Убедиться, что спринт активен.
    3. **Обработка незавершенных задач:** Это самая важная часть.
        - Найти все задачи в спринте, которые не в финальном статусе (например, `Done`).
        - В зависимости от параметра :
            - просто удалить их связь с текущим спринтом. Они вернутся в общий проект.
            - переместить их в указанный следующий спринт.
**Получение доски спринта:**

- **Эндпоинт:** `GET /api/sprints/:sprintId/board`
- **Логика (`SprintService.getSprintBoard`):**
    1. Получить все задачи, связанные с этим спринтом, через связующую таблицу.
    2. Отдать этот список задач на фронтенд. Фронтенд сам отобразит их в виде Kanban-доски, сгруппировав их
	